## 원시 타입 vs 참조 타입
https://velog.io/@gillog/%EC%9B%90%EC%8B%9C%ED%83%80%EC%9E%85-%EC%B0%B8%EC%A1%B0%ED%83%80%EC%9E%85Primitive-Type-Reference-Type

원시 타입 : 정수, 실수, 문자, 논리 리터럴 등의 ***실제 데이터값*** 을 저장하는 타입

참조 타입 : 객체(Object)의 번지를 참조(주소를 저장)하는 타입으로 메모리 번지 값을 통해 객체를 참조하는 타입 (문자열, 배열, 열거, 클래스, 인터페이스)

### 저장되는 곳
- 실제 객체 : 힙
- 참조 타입 변수 : 스택 영역에 객체들의 ***주소***를 저장, 객체의 주소를 불러와 사용하는 방식

### 참조 타입

- 정적 메모리 스택(Stack) 영역

스택 영역에는 기본타입 변수가 할당되고 변수의 실제 값들을 저장함

참조 타입의 변수들은 이 스택 영역에서 힙 영역에 생성된 객체들의 주소 값을 저장함

객체 안에 메소드의 작업이 종료되면 할당되었던 메모리 공간은 반환되어 비워짐

- 동적 메모리 힙(Heap) 영역

힙 영역에는 객체와 배열이 생성됨

그리고 참조타입(배열, 클래스, 인터페이스 등) 들이 이 객체들의 __주소__ 값을 저장하고 있음

기본타입 변수들과는 다르게 크기가 정해지지 않음

프로그램 실행시 메모리에 동적으로 할당됨

참조하는 변수가 없으면 자바의 __GC__가 제거함

### Boxing, Unboxing
- Boxing : 원시타입 -> 참조타입 변환
- Unboxing : 참조타입 -> 원시타입

### 원시타입과 참조타입 차이

- Null : 원시 x , 참조 o
~~~java
int i = null; // (x)

Integer integer = null; // (o)
~~~
- 제너릭 : 원시 x , 참조 o
~~~java
List<i> list; // (x)

List<Integer> list; // (o)
~~~

### 이렇게 알아보면 참조타입이 무조건 다 좋아보일수 있지만 원시타입의 장점은 따로 있음

### 원시타입 장점

- 접근 속도
원시타입은 '스택' 메모리에 값이 존재함

반면 참조타입은 하나의 인스턴스이기 때문에 '스택' 메모리에는 참조값만 있고, 실제 값은 힙 메모리에 존재함

그리고 값을 필요로 할 때마다 언박싱 과정을 거쳐야 하기에 원시타입과 비교해서 접근 속도가 느려짐 ( 매우 큰 숫자면 원시값이 나음 )
